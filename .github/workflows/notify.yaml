# .github/workflows/notify.yml
# This workflow is triggered ONLY after the main "CI/CD Pipeline" workflow completes.
name: Send Pipeline Notification

on:
  workflow_run:
    workflows: ["CI/CD Pipeline"] # IMPORTANT: This MUST match the 'name' of the main workflow
    types:
      - completed

jobs:
  notify:
    runs-on: ubuntu-latest
    # This single job runs on any completion and branches logic internally
    permissions:
      actions: read # <-- This is still required to get the log download URL
    steps:
      - name: Handle Success
        if: github.event.workflow_run.conclusion == 'success'
        env:
          TEAMS_WEBHOOK_URL: ${{ secrets.TEAMS_WEBHOOK_URL }}
          PIPELINE_NAME: ${{ github.event.workflow_run.name }}
          PIPELINE_URL: ${{ github.event.workflow_run.html_url }}
          COMMIT_SHA: ${{ github.event.workflow_run.head_sha }}
          AUTHOR: ${{ github.event.workflow_run.actor.login }}
        run: |
          JSON_PAYLOAD=$(cat <<EOF
          {
            "type": "message",
            "attachments": [{"contentType": "application/vnd.microsoft.card.adaptive","content": {"type": "AdaptiveCard","version": "1.4","body": [{"type": "TextBlock","text": "CI/CD Pipeline Succeeded: ${PIPELINE_NAME}","weight": "Bolder", "size": "Large", "color": "Good"},{"type": "FactSet","facts": [{"title": "Status:", "value": "âœ… Success"},{"title": "Author:", "value": "${AUTHOR}"},{"title": "Commit:", "value": "$(echo ${COMMIT_SHA} | cut -c1-7)"}]}],"actions": [{"type": "Action.OpenUrl", "title": "View Pipeline Run", "url": "${PIPELINE_URL}"}]}}]
          }
          EOF
          )
          curl -X POST -H "Content-Type: application/json" -d "$JSON_PAYLOAD" "$TEAMS_WEBHOOK_URL"

      - name: Handle Failure
        if: github.event.workflow_run.conclusion == 'failure'
        uses: actions/checkout@v4 # Checkout code to access the notify.py script

      - name: Setup Python for Failure Analysis
        if: github.event.workflow_run.conclusion == 'failure'
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      - name: Install Python dependencies
        if: github.event.workflow_run.conclusion == 'failure'
        run: pip install langchain langchain-google-genai requests

      - name: Download logs from failed run
        if: github.event.workflow_run.conclusion == 'failure'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Fetching jobs for run ${{ github.event.workflow_run.id }}"
          
          ATTEMPTS=0
          MAX_ATTEMPTS=5
          WAIT_SECONDS=10
          log_download_url=""

          # This loop will retry until the logUrl is available or it times out.
          until [ -n "$log_download_url" ]; do
            if [ $ATTEMPTS -eq $MAX_ATTEMPTS ]; then
              echo "Failed to fetch log URL after $MAX_ATTEMPTS attempts. Aborting."
              exit 1
            fi

            ATTEMPTS=$((ATTEMPTS + 1))
            echo "Attempting to fetch log URL... (Attempt ${ATTEMPTS}/${MAX_ATTEMPTS})"
            
            run_data_json=$(gh run view ${{ github.event.workflow_run.id }} --json jobs)
            log_download_url=$(echo "$run_data_json" | jq -r '.jobs[] | select(.conclusion == "failure") | .logUrl' | head -n 1)

            # Check if the URL is empty or the literal string "null"
            if [ -z "$log_download_url" ] || [ "$log_download_url" == "null" ]; then
              log_download_url="" # Reset to empty to ensure loop continues
              echo "Log URL not yet available. Waiting ${WAIT_SECONDS}s..."
              sleep $WAIT_SECONDS
            fi
          done
          
          echo "Found log download URL: $log_download_url"
          echo "Downloading with curl..."
          # Use curl with an Authorization header to download the zip file
          curl -L -o logs.zip -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" "$log_download_url"
          
          echo "Unzipping logs..."
          unzip -q logs.zip || echo "Unzip failed. The log archive might be empty or corrupted."
          
          echo "Concatenating all log files for analysis..."
          # Find all .txt files in all subdirectories and combine them into one file.
          find . -name '*.txt' -print0 | xargs -0 cat > failure_logs.txt
          
          echo "Logs for analysis saved to failure_logs.txt."

      - name: Run Analysis and Send Notification
        if: github.event.workflow_run.conclusion == 'failure'
        env:
          GOOGLE_API_KEY: ${{ secrets.GOOGLE_API_KEY }}
          TEAMS_WEBHOOK_URL: ${{ secrets.TEAMS_WEBHOOK_URL }}
          PIPELINE_STATUS: "failure"
          PIPELINE_NAME: ${{ github.event.workflow_run.name }}
          PIPELINE_URL: ${{ github.event.workflow_run.html_url }}
          COMMIT_SHA: ${{ github.event.workflow_run.head_sha }}
          AUTHOR: ${{ github.event.workflow_run.actor.login }}
        run: |
          python notify.py
